import logging
import os
import requests  # Pour envoyer des requ√™tes HTTP
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, CallbackContext

# Configuration des logs
logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)

# Cl√© API Telegram
TELEGRAM_TOKEN = "7922920905:AAGfYlyZQbDQiAbNGco4JSHj4qevLb1xNMQ"

# URL du backend Flask (remplacez par votre URL Ngrok)
BACKEND_URL = "https://e6e3-41-202-207-9.ngrok-free.app/log_journey"

# Variables globales pour g√©rer les √©tats des utilisateurs
user_states = {}

# Chemin du dossier des documents
DOCUMENTS_FOLDER = "documents"

# Fonction pour envoyer les donn√©es au backend
async def log_journey(chat_id, platform, journey):
    data = {
        "chat_id": chat_id,
        "platform": platform,
        "journey": journey
    }
    try:
        response = requests.post(BACKEND_URL, json=data)
        if response.status_code == 200:
            logging.info("Parcours enregistr√© avec succ√®s !")
        else:
            logging.error(f"Erreur lors de l'envoi des donn√©es au backend. Code de statut : {response.status_code}")
    except Exception as e:
        logging.error(f"Erreur lors de l'envoi des donn√©es au backend : {e}")

# Gestion des boutons du menu principal pour Telegram
async def start(update: Update, context: CallbackContext):
    keyboard = [
        [InlineKeyboardButton("üí∞ Probl√®mes de paiement", callback_data="1")],
        [InlineKeyboardButton("üìÅ T√©l√©chargement de documents", callback_data="2")],
        [InlineKeyboardButton("‚úèÔ∏è Modifications", callback_data="3")],
        [InlineKeyboardButton("‚ùì Questions g√©n√©rales", callback_data="4")],
        [InlineKeyboardButton("üõ†Ô∏è Probl√®mes techniques", callback_data="5")],
        [InlineKeyboardButton("0Ô∏è‚É£ Retour au menu principal", callback_data="0")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Bienvenue ! Veuillez choisir une option :", reply_markup=reply_markup)

# Gestion des sous-boutons dans Telegram
async def button_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    options = {
        "1": {
            "name": "Probl√®mes de paiement",
            "suboptions": [
                "1Ô∏è‚É£ Re√ßu non g√©n√©r√©",
                "2Ô∏è‚É£ Nom incorrect sur le re√ßu",
                "3Ô∏è‚É£ Impossible de retirer un re√ßu"
            ]
        },
        "2": {
            "name": "T√©l√©chargement de documents",
            "suboptions": [
                "1Ô∏è‚É£ Fiche de paiement introuvable",
                "2Ô∏è‚É£ Probl√®me d‚Äôimpression",
                "3Ô∏è‚É£ Demande de duplicata",
                "4Ô∏è‚É£ Autre probl√®me de t√©l√©chargement"
            ]
        },
        "3": {
            "name": "Modifications",
            "suboptions": [
                "1Ô∏è‚É£ Correction de date",
                "2Ô∏è‚É£ Modification du nom",
                "3Ô∏è‚É£ Changement d'adresse",
                "4Ô∏è‚É£ Autre demande de modification"
            ]
        },
        "4": {
            "name": "Questions g√©n√©rales",
            "suboptions": [
                "1Ô∏è‚É£ Comment l√©galiser un document ?",
                "2Ô∏è‚É£ Certificat m√©dical",
                "3Ô∏è‚É£ Facture minist√©rielle"
            ],
            "nestedSuboptions": {
                "2": [
                    "1Ô∏è‚É£ Co√ªt d‚Äôun certificat m√©dical",
                    "2Ô∏è‚É£ Comment obtenir un certificat m√©dical ?",
                    "3Ô∏è‚É£ Retirer son certificat m√©dical"
                ],
                "3": [
                    "1Ô∏è‚É£ Payer sa facture minist√©rielle"
                ]
            }
        },
        "5": {
            "name": "Probl√®mes techniques",
            "suboptions": [
                "1Ô∏è‚É£ Erreur de validation de paiement",
                "2Ô∏è‚É£ Num√©ro de dossier d√©j√† utilis√©",
                "3Ô∏è‚É£ Probl√®me de connexion au site",
                "4Ô∏è‚É£ Autre probl√®me technique"
            ]
        }
    }

    if query.data == "0":
        await start(update, context)
        return

    if query.data in options:
        buttons = [[InlineKeyboardButton(opt, callback_data=f"{query.data}_{i+1}")] for i, opt in enumerate(options[query.data]["suboptions"])]
        buttons.append([InlineKeyboardButton("0Ô∏è‚É£ Retour au menu principal", callback_data="0")])
        reply_markup = InlineKeyboardMarkup(buttons)
        await query.message.reply_text(f"Vous avez choisi : {options[query.data]['name']}\nVeuillez s√©lectionner une sous-option :", reply_markup=reply_markup)
        await log_journey(query.from_user.id, "telegram", options[query.data]['name'])
    else:
        await handle_suboption(update, context, query.data)

# Gestion des sous-sous-boutons dans Telegram
async def handle_suboption(update: Update, context: CallbackContext, option_id: str):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    user_states[user_id] = option_id  # Enregistrer l'√©tat de l'utilisateur

    if option_id == "1_1":  # Re√ßu non g√©n√©r√©
        await query.message.reply_text("Avez-vous d√©j√† effectu√© le paiement ?\n1Ô∏è‚É£ Oui\n2Ô∏è‚É£ Non")
        await log_journey(user_id, "telegram", "Probl√®mes de paiement ‚Üí Re√ßu non g√©n√©r√©")
    elif option_id == "1_2":  # Nom incorrect sur le re√ßu
        await query.message.reply_text("Veuillez fournir votre num√©ro de dossier pour v√©rification.")
        await log_journey(user_id, "telegram", "Probl√®mes de paiement ‚Üí Nom incorrect sur le re√ßu")
    elif option_id == "1_3":  # Impossible de retirer un re√ßu
        await query.message.reply_text("Avez-vous re√ßu un SMS avec un code unique apr√®s le paiement ?\n1Ô∏è‚É£ Oui\n2Ô∏è‚É£ Non")
        await log_journey(user_id, "telegram", "Probl√®mes de paiement ‚Üí Impossible de retirer un re√ßu")
    elif option_id == "2_1":  # Fiche de paiement introuvable
        await query.message.reply_text("Avez-vous d√©j√† effectu√© le paiement ?\n1Ô∏è‚É£ Oui\n2Ô∏è‚É£ Non")
        await log_journey(user_id, "telegram", "T√©l√©chargement de documents ‚Üí Fiche de paiement introuvable")
    elif option_id == "2_2":  # Probl√®me d‚Äôimpression
        await query.message.reply_text("Veuillez v√©rifier votre imprimante et r√©essayer. Si le probl√®me persiste, contactez-nous.")
        await log_journey(user_id, "telegram", "T√©l√©chargement de documents ‚Üí Probl√®me d‚Äôimpression")
    elif option_id == "2_3":  # Demande de duplicata
        await query.message.reply_text("Veuillez fournir votre num√©ro de dossier pour g√©n√©rer un duplicata.")
        await log_journey(user_id, "telegram", "T√©l√©chargement de documents ‚Üí Demande de duplicata")
    elif option_id == "2_4":  # Autre probl√®me de t√©l√©chargement
        await query.message.reply_text("Veuillez d√©crire bri√®vement le probl√®me rencontr√©.")
        await log_journey(user_id, "telegram", "T√©l√©chargement de documents ‚Üí Autre probl√®me de t√©l√©chargement")
    elif option_id == "3_1":  # Correction de date
        await query.message.reply_text("Veuillez fournir votre num√©ro de dossier et la date correcte.")
        await log_journey(user_id, "telegram", "Modifications ‚Üí Correction de date")
    elif option_id == "3_2":  # Modification du nom
        await query.message.reply_text("Veuillez fournir votre num√©ro de dossier et le nom correct.")
        await log_journey(user_id, "telegram", "Modifications ‚Üí Modification du nom")
    elif option_id == "3_3":  # Changement d'adresse
        await query.message.reply_text("Veuillez fournir votre num√©ro de dossier et la nouvelle adresse.")
        await log_journey(user_id, "telegram", "Modifications ‚Üí Changement d'adresse")
    elif option_id == "3_4":  # Autre demande de modification
        await query.message.reply_text("Veuillez d√©crire bri√®vement la modification demand√©e.")
        await log_journey(user_id, "telegram", "Modifications ‚Üí Autre demande de modification")
    elif option_id == "4_1":  # Comment l√©galiser un document ?
        await query.message.reply_text("Pour l√©galiser un document, veuillez vous rendre au minist√®re comp√©tent avec une copie du document et une pi√®ce d'identit√©.")
        await log_journey(user_id, "telegram", "Questions g√©n√©rales ‚Üí Comment l√©galiser un document ?")
    elif option_id == "4_2_1":  # Co√ªt d‚Äôun certificat m√©dical
        await query.message.reply_text("Le co√ªt d'un certificat m√©dical est de 5 000 FCFA.")
        await log_journey(user_id, "telegram", "Questions g√©n√©rales ‚Üí Certificat m√©dical ‚Üí Co√ªt d‚Äôun certificat m√©dical")
    elif option_id == "4_2_2":  # Comment obtenir un certificat m√©dical ?
        await query.message.reply_text("Pour obtenir un certificat m√©dical, veuillez vous rendre √† l'h√¥pital le plus proche avec une pi√®ce d'identit√© valide.")
        await log_journey(user_id, "telegram", "Questions g√©n√©rales ‚Üí Certificat m√©dical ‚Üí Comment obtenir un certificat m√©dical ?")
    elif option_id == "4_2_3":  # Retirer son certificat m√©dical
        await query.message.reply_text("Avez-vous d√©j√† effectu√© le paiement pour le certificat m√©dical ?\n1Ô∏è‚É£ Oui\n2Ô∏è‚É£ Non")
        await log_journey(user_id, "telegram", "Questions g√©n√©rales ‚Üí Certificat m√©dical ‚Üí Retirer son certificat m√©dical")
    elif option_id == "4_3_1":  # Payer sa facture minist√©rielle
        await query.message.reply_text("Voici le lien pour payer votre facture minist√©rielle : [lien de paiement]")
        await log_journey(user_id, "telegram", "Questions g√©n√©rales ‚Üí Facture minist√©rielle ‚Üí Payer sa facture minist√©rielle")
    elif option_id == "5_1":  # Erreur de validation de paiement
        await query.message.reply_text("Veuillez v√©rifier vos informations de paiement ou contacter votre banque.")
        await log_journey(user_id, "telegram", "Probl√®mes techniques ‚Üí Erreur de validation de paiement")
    elif option_id == "5_2":  # Num√©ro de dossier d√©j√† utilis√©
        await query.message.reply_text("Veuillez contacter le support technique pour v√©rification.")
        await log_journey(user_id, "telegram", "Probl√®mes techniques ‚Üí Num√©ro de dossier d√©j√† utilis√©")
    elif option_id == "5_3":  # Probl√®me de connexion au site
        await query.message.reply_text("Veuillez v√©rifier votre connexion internet ou r√©essayer plus tard.")
        await log_journey(user_id, "telegram", "Probl√®mes techniques ‚Üí Probl√®me de connexion au site")
    elif option_id == "5_4":  # Autre probl√®me technique
        await query.message.reply_text("Veuillez d√©crire bri√®vement le probl√®me technique rencontr√©.")
        await log_journey(user_id, "telegram", "Probl√®mes techniques ‚Üí Autre probl√®me technique")
    else:
        await query.message.reply_text("Option non reconnue. Veuillez r√©essayer.")

# Fonction principale de gestion des messages Telegram
async def handle_message(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    user_message = update.message.text.lower()

    # Retour au menu principal si l'utilisateur envoie "0"
    if user_message == "0":
        await start(update, context)
        return

    if user_id in user_states:
        option_id = user_states[user_id]

        # Gestion des questions "Avez-vous d√©j√† effectu√© le paiement ?"
        if option_id in ["1_1", "1_3", "2_1", "4_2_3"]:
            if user_message == "1":  # Oui
                await update.message.reply_text("Veuillez entrer votre code unique re√ßu par SMS :")
                user_states[user_id] = f"{option_id}_awaiting_code"  # Nouvel √©tat : en attente du code unique
            elif user_message == "2":  # Non
                await update.message.reply_text("Veuillez effectuer le paiement et revenir une fois termin√©.")
                del user_states[user_id]  # R√©initialiser l'√©tat de l'utilisateur
            else:
                await update.message.reply_text("Veuillez r√©pondre par '1' (Oui) ou '2' (Non).")
            return

        # Gestion du code unique
        if option_id.endswith("_awaiting_code"):
            if user_message.isdigit():
                code_unique = user_message
                file_path = os.path.join(DOCUMENTS_FOLDER, f"{code_unique}.pdf")
                if os.path.exists(file_path):
                    await update.message.reply_document(document=open(file_path, "rb"), caption="Voici votre document.")
                else:
                    await update.message.reply_text("‚ö†Ô∏è Code unique invalide. Veuillez v√©rifier et r√©essayer.")
            else:
                await update.message.reply_text("Veuillez entrer un code unique valide (chiffres uniquement).")
            del user_states[user_id]  # R√©initialiser l'√©tat de l'utilisateur
            return

    await update.message.reply_text("Veuillez choisir une option dans le menu principal.")

# Fonction principale pour d√©marrer le bot
def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    logging.info("Bot Telegram d√©marr√© avec succ√®s.")
    app.run_polling()

if __name__ == "__main__":
    main()